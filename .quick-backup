["qntest :Delete do
  result = parse(<<-'END', :a, 'abc 34')
    grammar Delete;
    options {language=Ruby;output=AST;}
    a : ID INT -> ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;
  END
  result.should == ''
end

test :SingleToken do
  result = parse(<<-'END', :a, 'abc')
    grammar SingleToken;
    options {language=Ruby;output=AST;}
    a : ID -> ID;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'abc'
end

test :SingleTokenToNewNode do
  result = parse(<<-'END', :a, 'abc')
    grammar SingleTokenToNewNode;
    options {language=Ruby;output=AST;}
    a : ID -> ID["x"];
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'x'
end

test :SingleTokenToNewNodeRoot do
  result = parse(<<-'END', :a, 'abc')
    grammar SingleTokenToNewNodeRoot;
    options {language=Ruby;output=AST;}
    a : ID -> ^(ID["x"] INT);
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(x INT)'
end

test :SingleTokenToNewNode2 do
  result = parse(<<-'END', :a, 'abc')
    grammar SingleTokenToNewNode2;
    options {language=Ruby;output=AST;}
    a : ID -> ID[ ];
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;
  END
  result.should == 'ID'
end

test :SingleCharLiteral do
  result = parse(<<-'END', :a, 'c')
    grammar SingleCharLiteral;
    options {language=Ruby;output=AST;}
    a : 'c' -> 'c';
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'c'
end

test :SingleStringLiteral do
  result = parse(<<-'END', :a, 'ick')
    grammar SingleStringLiteral;
    options {language=Ruby;output=AST;}
    a : 'ick' -> 'ick';
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'ick'
end

test :SingleRule do
  result = parse(<<-'END', :a, 'abc')
    grammar SingleRule;
    options {language=Ruby;output=AST;}
    a : b -> b;
    b : ID ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'abc'
end

test :ReorderTokens do
  result = parse(<<-'END', :a, 'abc 34')
    grammar ReorderTokens;
    options {language=Ruby;output=AST;}
    a : ID INT -> INT ID;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '34 abc'
end

test :ReorderTokenAndRule do
  result = parse(<<-'END', :a, 'abc 34')
    grammar ReorderTokenAndRule;
    options {language=Ruby;output=AST;}
    a : b INT -> INT b;
    b : ID ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '34 abc'
end

test :TokenTree do
  result = parse(<<-'END', :a, 'abc 34')
    grammar TokenTree;
    options {language=Ruby;output=AST;}
    a : ID INT -> ^(INT ID);
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(34 abc)'
end

test :TokenTreeAfterOtherStuff do
  result = parse(<<-'END', :a, 'void abc 34')
    grammar TokenTreeAfterOtherStuff;
    options {language=Ruby;output=AST;}
    a : 'void' ID INT -> 'void' ^(INT ID);
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'void (34 abc)'
end

test :NestedTokenTreeWithOuterLoop do
  result = parse(<<-'END', :a, 'a 1 b 2')
    grammar NestedTokenTreeWithOuterLoop;
    options {language=Ruby;output=AST;}
    tokens {DUH;}
    a : ID INT ID INT -> ^( DUH ID ^( DUH INT) )+ ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(DUH a (DUH 1)) (DUH b (DUH 2))'
end

test :OptionalSingleToken do
  result = parse(<<-'END', :a, 'abc')
    grammar OptionalSingleToken;
    options {language=Ruby;output=AST;}
    a : ID -> ID? ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'abc'
end

test :ClosureSingleToken do
  result = parse(<<-'END', :a, 'a b')
    grammar ClosureSingleToken;
    options {language=Ruby;output=AST;}
    a : ID ID -> ID* ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'a b'
end

test :PositiveClosureSingleToken do
  result = parse(<<-'END', :a, 'a b')
    grammar PositiveClosureSingleToken;
    options {language=Ruby;output=AST;}
    a : ID ID -> ID+ ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'a b'
end

test :OptionalSingleRule do
  result = parse(<<-'END', :a, 'abc')
    grammar OptionalSingleRule;
    options {language=Ruby;output=AST;}
    a : b -> b?;
    b : ID ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'abc'
end

test :ClosureSingleRule do
  result = parse(<<-'END', :a, 'a b')
    grammar ClosureSingleRule;
    options {language=Ruby;output=AST;}
    a : b b -> b*;
    b : ID ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'a b'
end

test :ClosureOfLabel do
  result = parse(<<-'END', :a, 'a b')
    grammar ClosureOfLabel;
    options {language=Ruby;output=AST;}
    a : x+=b x+=b -> $x*;
    b : ID ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'a b'
end

test :OptionalLabelNoListLabel do
  result = parse(<<-'END', :a, 'a')
    grammar OptionalLabelNoListLabel;
    options {language=Ruby;output=AST;}
    a : (x=ID)? -> $x?;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'a'
end

test :PositiveClosureSingleRule do
  result = parse(<<-'END', :a, 'a b')
    grammar PositiveClosureSingleRule;
    options {language=Ruby;output=AST;}
    a : b b -> b+;
    b : ID ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'a b'
end

test :SinglePredicateT do
  result = parse(<<-'END', :a, 'abc')
    grammar SinglePredicateT;
    options {language=Ruby;output=AST;}
    a : ID -> {true}? ID -> ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'abc'
end

test :SinglePredicateF do
  result = parse(<<-'END', :a, 'abc')
    grammar SinglePredicateF;
    options {language=Ruby;output=AST;}
    a : ID -> {false}? ID -> ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == ''
end

test :MultiplePredicate do
  result = parse(<<-'END', :a, 'a 2')
    grammar MultiplePredicate;
    options {language=Ruby;output=AST;}
    a : ID INT -> {false}? ID
               -> {true}? INT
               -> 
      ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '2'
end

test :MultiplePredicateTrees do
  result = parse(<<-'END', :a, 'a 2')
    grammar MultiplePredicateTrees;
    options {language=Ruby;output=AST;}
    a : ID INT -> {false}? ^(ID INT)
               -> {true}? ^(INT ID)
               -> ID
      ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(2 a)'
end

test :SimpleTree do
  result = parse(<<-'END', :a, '-34')
    grammar SimpleTree;
    options {language=Ruby;output=AST;}
    a : op INT -> ^(op INT);
    op : '+'|'-' ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(- 34)'
end

test :SimpleTree2 do
  result = parse(<<-'END', :a, '+ 34')
    grammar SimpleTree2;
    options {language=Ruby;output=AST;}
    a : op INT -> ^(INT op);
    op : '+'|'-' ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(34 +)'
end

test :NestedTrees do
  result = parse(<<-'END', :a, 'var a:int; b:float;')
    grammar NestedTrees;
    options {language=Ruby;output=AST;}
    a : 'var' (ID ':' type ';')+ -> ^('var' ^(':' ID type)+) ;
    type : 'int' | 'float' ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(var (: a int) (: b float))'
end

test :ImaginaryTokenCopy do
  result = parse(<<-'END', :a, 'a,b,c')
    grammar ImaginaryTokenCopy;
    options {language=Ruby;output=AST;}
    tokens {VAR;}
    a : ID (',' ID)*-> ^(VAR ID)+ ;
    type : 'int' | 'float' ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(VAR a) (VAR b) (VAR c)'
end

test :TokenUnreferencedOnLeftButDefined do
  result = parse(<<-'END', :a, 'a')
    grammar TokenUnreferencedOnLeftButDefined;
    options {language=Ruby;output=AST;}
    tokens {VAR;}
    a : b -> ID ;
    b : ID ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'ID'
end

test :ImaginaryTokenCopySetText do
  result = parse(<<-'END', :a, 'a,b,c')
    grammar ImaginaryTokenCopySetText;
    options {language=Ruby;output=AST;}
    tokens {VAR;}
    a : ID (',' ID)*-> ^(VAR["var"] ID)+ ;
    type : 'int' | 'float' ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(var a) (var b) (var c)'
end

test :ImaginaryTokenNoCopyFromToken do
  result = parse(<<-'END', :a, '{a b c}')
    grammar ImaginaryTokenNoCopyFromToken;
    options {language=Ruby;output=AST;}
    tokens {BLOCK;}
    a : lc='{' ID+ '}' -> ^(BLOCK[$lc] ID+) ;
    type : 'int' | 'float' ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '({ a b c)'
end

test :ImaginaryTokenNoCopyFromTokenSetText do
  result = parse(<<-'END', :a, '{a b c}')
    grammar ImaginaryTokenNoCopyFromTokenSetText;
    options {language=Ruby;output=AST;}
    tokens {BLOCK;}
    a : lc='{' ID+ '}' -> ^(BLOCK[$lc,"block"] ID+) ;
    type : 'int' | 'float' ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(block a b c)'
end

test :MixedRewriteAndAutoAST do
  result = parse(<<-'END', :a, 'a 1 2')
    grammar MixedRewriteAndAutoAST;
    options {language=Ruby;output=AST;}
    tokens {BLOCK;}
    a : b b^ ; // 2nd b matches only an INT; can make it root
    b : ID INT -> INT ID
      | INT
      ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;
  END
  result.should == '(2 1 a)'
end

test :SubruleWithRewrite do
  result = parse(<<-'END', :a, 'a 1 2 3')
    grammar SubruleWithRewrite;
    options {language=Ruby;output=AST;}
    tokens {BLOCK;}
    a : b b ;
    b : (ID INT -> INT ID | INT INT -> INT+ )
      ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '1 a 2 3'
end

test :SubruleWithRewrite2 do
  result = parse(<<-'END', :a, 'int a; int b=3;')
    grammar SubruleWithRewrite2;
    options {language=Ruby;output=AST;}
    tokens {TYPE;}
    a : b b ;
    b : 'int'
        ( ID -> ^(TYPE 'int' ID)
        | ID '=' INT -> ^(TYPE 'int' ID INT)
        )
        ';'
      ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(TYPE int a) (TYPE int b 3)'
end

test :NestedRewriteShutsOffAutoAST do
  result = parse(<<-'END', :a, 'a b c d; 42')
    grammar NestedRewriteShutsOffAutoAST;
    options {language=Ruby;output=AST;}
    tokens {BLOCK;}
    a : b b ;
    b : ID ( ID (last=ID -> $last)+ ) ';' // get last ID
      | INT // should still get auto AST construction
      ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'd 42'
end

test :RewriteActions do
  result = parse(<<-'END', :a, '3')
    grammar RewriteActions;
    options {language=Ruby;output=AST;}
    a : atom -> ^({ @adaptor.create!(INT,"9") } atom) ;
    atom : INT ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(9 3)'
end

test :RewriteActions2 do
  result = parse(<<-'END', :a, '3')
    grammar RewriteActions2;
    options {language=Ruby;output=AST;}
    a : atom -> { @adaptor.create!(INT,"9") } atom ;
    atom : INT ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '9 3'
end

test :RefToOldValue do
  result = parse(<<-'END', :a, '3+4+5')
    grammar RefToOldValue;
    options {language=Ruby;output=AST;}
    tokens {BLOCK;}
    a : (atom -> atom) (op='+' r=atom -> ^($op $a $r) )* ;
    atom : INT ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(+ (+ 3 4) 5)'
end

test :CopySemanticsForRules do
  result = parse(<<-'END', :a, '3')
    grammar CopySemanticsForRules;
    options {language=Ruby;output=AST;}
    tokens {BLOCK;}
    a : atom -> ^(atom atom) ; // NOT CYCLE! (dup atom)
    atom : INT ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(3 3)'
end

test :CopySemanticsForRules2 do
  result = parse(<<-'END', :a, 'int a,b,c;')
    grammar CopySemanticsForRules2;
    options {language=Ruby;output=AST;}
    a : type ID (',' ID)* ';' -> ^(type ID)+ ;
    type : 'int' ;
    ID : 'a'..'z'+ ;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(int a) (int b) (int c)'
end

test :CopySemanticsForRules3 do
  result = parse(<<-'END', :a, 'public int a,b,c;')
    grammar CopySemanticsForRules3;
    options {language=Ruby;output=AST;}
    a : modifier? type ID (',' ID)* ';' -> ^(type modifier? ID)+ ;
    type : 'int' ;
    modifier : 'public' ;
    ID : 'a'..'z'+ ;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(int public a) (int public b) (int public c)'
end

test :CopySemanticsForRules3Double do
  result = parse(<<-'END', :a, 'public int a,b,c;')
    grammar CopySemanticsForRules3Double;
    options {language=Ruby;output=AST;}
    a : modifier? type ID (',' ID)* ';' -> ^(type modifier? ID)+ ^(type modifier? ID)+ ;
    type : 'int' ;
    modifier : 'public' ;
    ID : 'a'..'z'+ ;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(int public a) (int public b) (int public c) (int public a) (int public b) (int public c)'
end

test :CopySemanticsForRules4 do
  result = parse(<<-'END', :a, 'public int a,b,c;')
    grammar CopySemanticsForRules4;
    options {language=Ruby;output=AST;}
    tokens {MOD;}
    a : modifier? type ID (',' ID)* ';' -> ^(type ^(MOD modifier)? ID)+ ;
    type : 'int' ;
    modifier : 'public' ;
    ID : 'a'..'z'+ ;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(int (MOD public) a) (int (MOD public) b) (int (MOD public) c)'
end

test :CopySemanticsLists do
  result = parse(<<-'END', :a, 'a,b,c;')
    grammar CopySemanticsLists;
    options {language=Ruby;output=AST;}
    tokens {MOD;}
    a : ID (',' ID)* ';' -> ID+ ID+ ;
    ID : 'a'..'z'+ ;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'a b c a b c'
end

test :CopyRuleLabel do
  result = parse(<<-'END', :a, 'a')
    grammar CopyRuleLabel;
    options {language=Ruby;output=AST;}
    tokens {BLOCK;}
    a : x=b -> $x $x;
    b : ID ;
    ID : 'a'..'z'+ ;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'a a'
end

test :CopyRuleLabel2 do
  result = parse(<<-'END', :a, 'a')
    grammar CopyRuleLabel2;
    options {language=Ruby;output=AST;}
    tokens {BLOCK;}
    a : x=b -> ^($x $x);
    b : ID ;
    ID : 'a'..'z'+ ;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(a a)'
end

test :QueueingOfTokens do
  result = parse(<<-'END', :a, 'int a,b,c;')
    grammar QueueingOfTokens;
    options {language=Ruby;output=AST;}
    a : 'int' ID (',' ID)* ';' -> ^('int' ID+) ;
    op : '+'|'-' ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(int a b c)'
end

test :CopyOfTokens do
  result = parse(<<-'END', :a, 'int a;')
    grammar CopyOfTokens;
    options {language=Ruby;output=AST;}
    a : 'int' ID ';' -> 'int' ID 'int' ID ;
    op : '+'|'-' ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'int a int a'
end

test :TokenCopyInLoop do
  result = parse(<<-'END', :a, 'int a,b,c;')
    grammar TokenCopyInLoop;
    options {language=Ruby;output=AST;}
    a : 'int' ID (',' ID)* ';' -> ^('int' ID)+ ;
    op : '+'|'-' ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(int a) (int b) (int c)'
end

test :TokenCopyInLoopAgainstTwoOthers do
  result = parse(<<-'END', :a, 'int a:1,b:2,c:3;')
    grammar TokenCopyInLoopAgainstTwoOthers;
    options {language=Ruby;output=AST;}
    a : 'int' ID ':' INT (',' ID ':' INT)* ';' -> ^('int' ID INT)+ ;
    op : '+'|'-' ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(int a 1) (int b 2) (int c 3)'
end

test :ListRefdOneAtATime do
  result = parse(<<-'END', :a, 'a b c')
    grammar ListRefdOneAtATime;
    options {language=Ruby;output=AST;}
    a : ID+ -> ID ID ID ; // works if 3 input IDs
    op : '+'|'-' ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'a b c'
end

test :SplitListWithLabels do
  result = parse(<<-'END', :a, 'a b c')
    grammar SplitListWithLabels;
    options {language=Ruby;output=AST;}
    tokens {VAR;}
    a : first=ID others+=ID* -> $first VAR $others+ ;
    op : '+'|'-' ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'a VAR b c'
end

test :ComplicatedMelange do
  result = parse(<<-'END', :a, 'a a b b b c c c d')
    grammar ComplicatedMelange;
    options {language=Ruby;output=AST;}
    tokens {BLOCK;}
    a : A A b=B B b=B c+=C C c+=C D {s=$D.text} -> A+ B+ C+ D ;
    type : 'int' | 'float' ;
    A : 'a' ;
    B : 'b' ;
    C : 'c' ;
    D : 'd' ;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'a a b b b c c c d'
end

test :RuleLabel do
  result = parse(<<-'END', :a, 'a')
    grammar RuleLabel;
    options {language=Ruby;output=AST;}
    tokens {BLOCK;}
    a : x=b -> $x;
    b : ID ;
    ID : 'a'..'z'+ ;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'a'
end

test :AmbiguousRule do
  result = parse(<<-'END', :a, 'abc 34')
    grammar AmbiguousRule;
    options {language=Ruby;output=AST;}
    a : ID a -> a | INT ;
    ID : 'a'..'z'+ ;
    INT: '0'..'9'+ ;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '34'
end

test :RuleListLabel do
  result = parse(<<-'END', :a, 'a b')
    grammar RuleListLabel;
    options {language=Ruby;output=AST;}
    tokens {BLOCK;}
    a : x+=b x+=b -> $x+;
    b : ID ;
    ID : 'a'..'z'+ ;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'a b'
end

test :RuleListLabel2 do
  result = parse(<<-'END', :a, 'a b')
    grammar RuleListLabel2;
    options {language=Ruby;output=AST;}
    tokens {BLOCK;}
    a : x+=b x+=b -> $x $x*;
    b : ID ;
    ID : 'a'..'z'+ ;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'a b'
end

test :Optional do
  result = parse(<<-'END', :a, 'a')
    grammar Optional;
    options {language=Ruby;output=AST;}
    tokens {BLOCK;}
    a : x=b (y=b)? -> $x $y?;
    b : ID ;
    ID : 'a'..'z'+ ;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'a'
end

test :Optional2 do
  result = parse(<<-'END', :a, 'a b')
    grammar Optional2;
    options {language=Ruby;output=AST;}
    tokens {BLOCK;}
    a : x=ID (y=b)? -> $x $y?;
    b : ID ;
    ID : 'a'..'z'+ ;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'a b'
end

test :Optional3 do
  result = parse(<<-'END', :a, 'a b')
    grammar Optional3;
    options {language=Ruby;output=AST;}
    tokens {BLOCK;}
    a : x=ID (y=b)? -> ($x $y)?;
    b : ID ;
    ID : 'a'..'z'+ ;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'a b'
end

test :Optional4 do
  result = parse(<<-'END', :a, 'a b')
    grammar Optional4;
    options {language=Ruby;output=AST;}
    tokens {BLOCK;}
    a : x+=ID (y=b)? -> ($x $y)?;
    b : ID ;
    ID : 'a'..'z'+ ;
    WS : (' '|'\n') {$channel=HIDDEN;} ;
  END
  result.should == 'a b'
end

test :Optional5 do
  result = parse(<<-'END', :a, 'a')
    grammar Optional5;
    options {language=Ruby;output=AST;}
    tokens {BLOCK;}
    a : ID -> ID? ; // match an ID to optional ID
    b : ID ;
    ID : 'a'..'z'+ ;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'a'
end

test :ArbitraryExprType do
  result = parse(<<-'END', :a, 'a b')
    grammar ArbitraryExprType;
    options {language=Ruby;output=AST;}
    tokens {BLOCK;}
    a : x+=b x+=b -> {ANTLR3::CommonTree.new(nil)};
    b : ID ;
    ID : 'a'..'z'+ ;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == ''
end

test :Set do
  result = parse(<<-'END', :a, '2 a 34 de')
    grammar SetT;
    options {language=Ruby;output=AST;} 
    a: (INT|ID)+ -> INT+ ID+ ;
    INT: '0'..'9'+;
    ID : 'a'..'z'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '2 34 a de'
end

test :Set2 do
  result = parse(<<-'END', :a, '2')
    grammar Set2;
    options {language=Ruby;output=AST;} 
    a: (INT|ID) -> INT? ID? ;
    INT: '0'..'9'+;
    ID : 'a'..'z'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '2'
end

test :SetWithLabel do
  warn('test SetWithLabel officially broken')
  #result = parse(<<-'END', :a, '2')
  #  grammar SetWithLabel;
  #  options {language=Ruby;output=AST;} 
  #  a : x=(INT|ID) -> $x ;
  #  INT: '0'..'9'+;
  #  ID : 'a'..'z'+;
  #  WS : (' '|'\n') {$channel=HIDDEN;} ;
  #
  #END
  #result.should == '2'
end

test :RewriteAction do
  result = parse(<<-'END', :r, '25')
    grammar RewriteAction; 
    options {language=Ruby;output=AST;}
    tokens { FLOAT; }
    r
        : INT -> {ANTLR3::CommonTree.new(create_token(FLOAT, nil, "#{$INT.text}.0"))} 
        ; 
    INT : '0'..'9'+; 
    WS: (' ' | '\n' | '\t')+ {$channel = HIDDEN;};

  END
  result.should == '25.0'
end

test :OptionalSubruleWithoutRealElements do
  result = parse(<<-'END', :modulo, 'modulo abc (x y #)')
    grammar OptionalSubruleWithoutRealElements;
    options {language=Ruby;output=AST;} 
    tokens {PARMS;} 
    
    modulo 
     : 'modulo' ID ('(' parms+ ')')? -> ^('modulo' ID ^(PARMS parms+)?) 
     ; 
    parms : '#'|ID; 
    ID : ('a'..'z' | 'A'..'Z')+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(modulo abc (PARMS x y #))'
end

test :Wildcard do
  result = parse(<<-'END', :a, 'abc 34')
    grammar Wildcard;
    options {language=Ruby;output=AST;}
    a : ID c=. -> $c;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '34'
end

test :ExtraTokenInSimpleDecl do
  result, errors = parse(<<-'END', :decl, 'int 34 x=1;', true)
    grammar ExtraTokenInSimpleDecl;
    options {language=Ruby;output=AST;}
    tokens {EXPR;}
    decl : type ID '=' INT ';' -> ^(EXPR type ID INT) ;
    type : 'int' | 'float' ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  errors.should == ['line 1:4 extraneous input "34" expecting ID']
  result.should == '(EXPR int x 1)'
end

test :MissingIDInSimpleDecl do
  result, errors = parse(<<-'END', :decl, 'int =1;', true)
    grammar MissingIDInSimpleDecl;
    options {language=Ruby;output=AST;}
    tokens {EXPR;}
    decl : type ID '=' INT ';' -> ^(EXPR type ID INT) ;
    type : 'int' | 'float' ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  errors.should == ['line 1:4 missing ID at "="']
  result.should == '(EXPR int <missing ID> 1)'
end

test :MissingSetInSimpleDecl do
  result, errors = parse(<<-'END', :decl, 'x=1;', true)
    grammar MissingSetInSimpleDecl;
    options {language=Ruby;output=AST;}
    tokens {EXPR;}
    decl : type ID '=' INT ';' -> ^(EXPR type ID INT) ;
    type : 'int' | 'float' ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  errors.should == ['line 1:0 mismatched input "x" expecting set nil']
  result.should == '(EXPR <error: x> x 1)'
end

test :MissingTokenGivesErrorNode do
  require 'trace-event'
  #Tracer.new do |event|
  #  puts(event.to_s + ' : %p' % event.__self__) if event.__self__.class.to_s =~ /CommonToken\b/
  #end.trace do
  result, errors = parse(<<-'END', :a, 'abc', true)
    grammar MissingTokenGivesErrorNode;
    options {language=Ruby;output=AST;}
    a : ID INT -> ID INT ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  errors.should == ["line 0:-1 missing INT at \"<EOF>\""]
  result.should == 'abc <missing INT>'
  #end
end

test :ExtraTokenGivesErrorNode do
  result, errors = parse(<<-'END', :a, 'abc ick 34', true)
    grammar ExtraTokenGivesErrorNode;
    options {language=Ruby;output=AST;}
    a : b c -> b c;
    b : ID -> ID ;
    c : INT -> INT ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  errors.should == ['line 1:4 extraneous input "ick" expecting INT']
  result.should == 'abc 34'
end

test :MissingFirstTokenGivesErrorNode do
  result, errors = parse(<<-'END', :a, '34', true)
    grammar MissingFirstTokenGivesErrorNode;
    options {language=Ruby;output=AST;}
    a : ID INT -> ID INT ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  errors.should == ['line 1:0 missing ID at "34"']
  result.should == '<missing ID> 34'
end

test :MissingFirstTokenGivesErrorNode2 do
  result, errors = parse(<<-'END', :a, '34', true)
    grammar MissingFirstTokenGivesErrorNode2;
    options {language=Ruby;output=AST;}
    a : b c -> b c;
    b : ID -> ID ;
    c : INT -> INT ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  errors.should == ['line 1:0 missing ID at "34"']
  result.should == '<missing ID> 34'
end

test :NoViableAltGivesErrorNode do
  result, errors = parse(<<-'END', :a, '*', true)
    grammar NoViableAltGivesErrorNode;
    options {language=Ruby;output=AST;}
    a : b -> b | c -> c;
    b : ID -> ID ;
    c : INT -> INT ;
    ID : 'a'..'z'+ ;
    S : '*' ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  errors.should == ['line 1:0 no viable alternative at input "*"']
  result.should == '<unexpected: 0 S["*"] @ line 1 col 0 (0..0), resync = *>'
end

test :Cardinality do
  lambda do
    parse(<<-'END', :a, "a b 3 4 5")
      grammar Cardinality;
      options {language=Ruby;output=AST;}
      tokens {BLOCK;}
      a : ID ID INT INT INT -> (ID INT)+;
      ID : 'a'..'z'+ ;
      INT : '0'..'9'+; 
      WS : (' '|'\n') {$channel=HIDDEN;} ;
    END
  end.should raise_error(ANTLR3::Error::RewriteCardinalityError)
end
test :Cardinality2 do
  lambda do
    parse(<<-'END', :a, "a b")
      grammar Cardinality2;
      options {language=Ruby;output=AST;}
      tokens {BLOCK;}
      a : ID+ -> ID ID ID ; // only 2 input IDs
      op : '+'|'-' ;
      ID : 'a'..'z'+ ;
      INT : '0'..'9'+;
      WS : (' '|'\n') {$channel=HIDDEN;} ;
    END
  end.should raise_error(ANTLR3::Error::RewriteCardinalityError)
end
test :Cardinality3 do
  lambda do
    parse(<<-'END', :a, "3")
      grammar Cardinality3;
      options {language=Ruby;output=AST;}
      tokens {BLOCK;}
      a : ID? INT -> ID INT ;
      op : '+'|'-' ;
      ID : 'a'..'z'+ ;
      INT : '0'..'9'+;
      WS : (' '|'\n') {$channel=HIDDEN;} ;
    END
  end.should raise_error(ANTLR3::Error::RewriteEmptyStream)
end
test :LoopCardinality do
  lambda do
    parse(<<-'END', :a, "3")
      grammar LoopCardinality;
      options {language=Ruby;output=AST;}
      a : ID? INT -> ID+ INT ;
      op : '+'|'-' ;
      ID : 'a'..'z'+ ;
      INT : '0'..'9'+;
      WS : (' '|'\n') {$channel=HIDDEN;} ;
    END
  end.should raise_error(ANTLR3::Error::RewriteEarlyExit)
end

[XS:
Block
:	full"ûtest :Delete do
  result = parse(<<-'END', :a, 'abc 34')
    grammar Delete;
    options {language=Ruby;output=AST;}
    a : ID INT -> ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;
  END
  result.should == ''
end:	name"Delete:	body"ç  result = parse(<<-'END', :a, 'abc 34')
    grammar Delete;
    options {language=Ruby;output=AST;}
    a : ID INT -> ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;
  END
  result.should == '':	desc"5deletion by leaving the right side of `->' blank:problem0S; 
;"test :SingleToken do
  result = parse(<<-'END', :a, 'abc')
    grammar SingleToken;
    options {language=Ruby;output=AST;}
    a : ID -> ID;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'abc'
end;"SingleToken;"ë  result = parse(<<-'END', :a, 'abc')
    grammar SingleToken;
    options {language=Ruby;output=AST;}
    a : ID -> ID;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'abc';	"2mapping a single token to a single token node;
0S; 
;"test :SingleTokenToNewNode do
  result = parse(<<-'END', :a, 'abc')
    grammar SingleTokenToNewNode;
    options {language=Ruby;output=AST;}
    a : ID -> ID["x"];
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'x'
end;"SingleTokenToNewNode;"÷  result = parse(<<-'END', :a, 'abc')
    grammar SingleTokenToNewNode;
    options {language=Ruby;output=AST;}
    a : ID -> ID["x"];
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'x';	0;
0S; 
;".test :SingleTokenToNewNodeRoot do
  result = parse(<<-'END', :a, 'abc')
    grammar SingleTokenToNewNodeRoot;
    options {language=Ruby;output=AST;}
    a : ID -> ^(ID["x"] INT);
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(x INT)'
end;"SingleTokenToNewNodeRoot;"  result = parse(<<-'END', :a, 'abc')
    grammar SingleTokenToNewNodeRoot;
    options {language=Ruby;output=AST;}
    a : ID -> ^(ID["x"] INT);
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(x INT)';	0;
0S; 
;"test :SingleTokenToNewNode2 do
  result = parse(<<-'END', :a, 'abc')
    grammar SingleTokenToNewNode2;
    options {language=Ruby;output=AST;}
    a : ID -> ID[ ];
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;
  END
  result.should == 'ID'
end;"SingleTokenToNewNode2;"ö  result = parse(<<-'END', :a, 'abc')
    grammar SingleTokenToNewNode2;
    options {language=Ruby;output=AST;}
    a : ID -> ID[ ];
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;
  END
  result.should == 'ID';	0;
0S; 
;"test :SingleCharLiteral do
  result = parse(<<-'END', :a, 'c')
    grammar SingleCharLiteral;
    options {language=Ruby;output=AST;}
    a : 'c' -> 'c';
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'c'
end;"SingleCharLiteral;"ï  result = parse(<<-'END', :a, 'c')
    grammar SingleCharLiteral;
    options {language=Ruby;output=AST;}
    a : 'c' -> 'c';
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'c';	0;
0S; 
;"test :SingleStringLiteral do
  result = parse(<<-'END', :a, 'ick')
    grammar SingleStringLiteral;
    options {language=Ruby;output=AST;}
    a : 'ick' -> 'ick';
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'ick'
end;"SingleStringLiteral;"ù  result = parse(<<-'END', :a, 'ick')
    grammar SingleStringLiteral;
    options {language=Ruby;output=AST;}
    a : 'ick' -> 'ick';
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'ick';	0;
0S; 
;"test :SingleRule do
  result = parse(<<-'END', :a, 'abc')
    grammar SingleRule;
    options {language=Ruby;output=AST;}
    a : b -> b;
    b : ID ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'abc'
end;"SingleRule;"õ  result = parse(<<-'END', :a, 'abc')
    grammar SingleRule;
    options {language=Ruby;output=AST;}
    a : b -> b;
    b : ID ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'abc';	0;
0S; 
;"test :ReorderTokens do
  result = parse(<<-'END', :a, 'abc 34')
    grammar ReorderTokens;
    options {language=Ruby;output=AST;}
    a : ID INT -> INT ID;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '34 abc'
end;"ReorderTokens;"û  result = parse(<<-'END', :a, 'abc 34')
    grammar ReorderTokens;
    options {language=Ruby;output=AST;}
    a : ID INT -> INT ID;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '34 abc';	0;
0S; 
;"-test :ReorderTokenAndRule do
  result = parse(<<-'END', :a, 'abc 34')
    grammar ReorderTokenAndRule;
    options {language=Ruby;output=AST;}
    a : b INT -> INT b;
    b : ID ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '34 abc'
end;"ReorderTokenAndRule;"  result = parse(<<-'END', :a, 'abc 34')
    grammar ReorderTokenAndRule;
    options {language=Ruby;output=AST;}
    a : b INT -> INT b;
    b : ID ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '34 abc';	0;
0S; 
;"test :TokenTree do
  result = parse(<<-'END', :a, 'abc 34')
    grammar TokenTree;
    options {language=Ruby;output=AST;}
    a : ID INT -> ^(INT ID);
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(34 abc)'
end;"TokenTree;"ü  result = parse(<<-'END', :a, 'abc 34')
    grammar TokenTree;
    options {language=Ruby;output=AST;}
    a : ID INT -> ^(INT ID);
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(34 abc)';	0;
0S; 
;"Itest :TokenTreeAfterOtherStuff do
  result = parse(<<-'END', :a, 'void abc 34')
    grammar TokenTreeAfterOtherStuff;
    options {language=Ruby;output=AST;}
    a : 'void' ID INT -> 'void' ^(INT ID);
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'void (34 abc)'
end;"TokenTreeAfterOtherStuff;"#  result = parse(<<-'END', :a, 'void abc 34')
    grammar TokenTreeAfterOtherStuff;
    options {language=Ruby;output=AST;}
    a : 'void' ID INT -> 'void' ^(INT ID);
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'void (34 abc)';	0;
0S; 
;"ztest :NestedTokenTreeWithOuterLoop do
  result = parse(<<-'END', :a, 'a 1 b 2')
    grammar NestedTokenTreeWithOuterLoop;
    options {language=Ruby;output=AST;}
    tokens {DUH;}
    a : ID INT ID INT -> ^( DUH ID ^( DUH INT) )+ ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(DUH a (DUH 1)) (DUH b (DUH 2))'
end;"!NestedTokenTreeWithOuterLoop;"P  result = parse(<<-'END', :a, 'a 1 b 2')
    grammar NestedTokenTreeWithOuterLoop;
    options {language=Ruby;output=AST;}
    tokens {DUH;}
    a : ID INT ID INT -> ^( DUH ID ^( DUH INT) )+ ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(DUH a (DUH 1)) (DUH b (DUH 2))';	0;
0S; 
;"test :OptionalSingleToken do
  result = parse(<<-'END', :a, 'abc')
    grammar OptionalSingleToken;
    options {language=Ruby;output=AST;}
    a : ID -> ID? ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'abc'
end;"OptionalSingleToken;"õ  result = parse(<<-'END', :a, 'abc')
    grammar OptionalSingleToken;
    options {language=Ruby;output=AST;}
    a : ID -> ID? ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'abc';	0;
0S; 
;"test :ClosureSingleToken do
  result = parse(<<-'END', :a, 'a b')
    grammar ClosureSingleToken;
    options {language=Ruby;output=AST;}
    a : ID ID -> ID* ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'a b'
end;"ClosureSingleToken;"÷  result = parse(<<-'END', :a, 'a b')
    grammar ClosureSingleToken;
    options {language=Ruby;output=AST;}
    a : ID ID -> ID* ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'a b';	0;
0S; 
;"'test :PositiveClosureSingleToken do
  result = parse(<<-'END', :a, 'a b')
    grammar PositiveClosureSingleToken;
    options {language=Ruby;output=AST;}
    a : ID ID -> ID+ ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'a b'
end;"PositiveClosureSingleToken;"ÿ  result = parse(<<-'END', :a, 'a b')
    grammar PositiveClosureSingleToken;
    options {language=Ruby;output=AST;}
    a : ID ID -> ID+ ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'a b';	0;
0S; 
;"test :OptionalSingleRule do
  result = parse(<<-'END', :a, 'abc')
    grammar OptionalSingleRule;
    options {language=Ruby;output=AST;}
    a : b -> b?;
    b : ID ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'abc'
end;"OptionalSingleRule;"þ  result = parse(<<-'END', :a, 'abc')
    grammar OptionalSingleRule;
    options {language=Ruby;output=AST;}
    a : b -> b?;
    b : ID ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'abc';	0;
0S; 
;"test :ClosureSingleRule do
  result = parse(<<-'END', :a, 'a b')
    grammar ClosureSingleRule;
    options {language=Ruby;output=AST;}
    a : b b -> b*;
    b : ID ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'a b'
end;"ClosureSingleRule;"ÿ  result = parse(<<-'END', :a, 'a b')
    grammar ClosureSingleRule;
    options {language=Ruby;output=AST;}
    a : b b -> b*;
    b : ID ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'a b';	0;
0S; 
;"test :ClosureOfLabel do
  result = parse(<<-'END', :a, 'a b')
    grammar ClosureOfLabel;
    options {language=Ruby;output=AST;}
    a : x+=b x+=b -> $x*;
    b : ID ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'a b'
end;"ClosureOfLabel;"  result = parse(<<-'END', :a, 'a b')
    grammar ClosureOfLabel;
    options {language=Ruby;output=AST;}
    a : x+=b x+=b -> $x*;
    b : ID ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'a b';	0;
0S; 
;" test :OptionalLabelNoListLabel do
  result = parse(<<-'END', :a, 'a')
    grammar OptionalLabelNoListLabel;
    options {language=Ruby;output=AST;}
    a : (x=ID)? -> $x?;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'a'
end;"OptionalLabelNoListLabel;"ú  result = parse(<<-'END', :a, 'a')
    grammar OptionalLabelNoListLabel;
    options {language=Ruby;output=AST;}
    a : (x=ID)? -> $x?;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'a';	0;
0S; 
;".test :PositiveClosureSingleRule do
  result = parse(<<-'END', :a, 'a b')
    grammar PositiveClosureSingleRule;
    options {language=Ruby;output=AST;}
    a : b b -> b+;
    b : ID ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'a b'
end;"PositiveClosureSingleRule;"  result = parse(<<-'END', :a, 'a b')
    grammar PositiveClosureSingleRule;
    options {language=Ruby;output=AST;}
    a : b b -> b+;
    b : ID ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'a b';	0;
0S; 
;"test :SinglePredicateT do
  result = parse(<<-'END', :a, 'abc')
    grammar SinglePredicateT;
    options {language=Ruby;output=AST;}
    a : ID -> {true}? ID -> ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'abc'
end;"SinglePredicateT;"ü  result = parse(<<-'END', :a, 'abc')
    grammar SinglePredicateT;
    options {language=Ruby;output=AST;}
    a : ID -> {true}? ID -> ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'abc';	0;
0S; 
;"test :SinglePredicateF do
  result = parse(<<-'END', :a, 'abc')
    grammar SinglePredicateF;
    options {language=Ruby;output=AST;}
    a : ID -> {false}? ID -> ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == ''
end;"SinglePredicateF;"ú  result = parse(<<-'END', :a, 'abc')
    grammar SinglePredicateF;
    options {language=Ruby;output=AST;}
    a : ID -> {false}? ID -> ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '';	0;
0S; 
;"Stest :MultiplePredicate do
  result = parse(<<-'END', :a, 'a 2')
    grammar MultiplePredicate;
    options {language=Ruby;output=AST;}
    a : ID INT -> {false}? ID
               -> {true}? INT
               -> 
      ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '2'
end;"MultiplePredicate;"4  result = parse(<<-'END', :a, 'a 2')
    grammar MultiplePredicate;
    options {language=Ruby;output=AST;}
    a : ID INT -> {false}? ID
               -> {true}? INT
               -> 
      ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '2';	0;
0S; 
;"ptest :MultiplePredicateTrees do
  result = parse(<<-'END', :a, 'a 2')
    grammar MultiplePredicateTrees;
    options {language=Ruby;output=AST;}
    a : ID INT -> {false}? ^(ID INT)
               -> {true}? ^(INT ID)
               -> ID
      ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(2 a)'
end;"MultiplePredicateTrees;"L  result = parse(<<-'END', :a, 'a 2')
    grammar MultiplePredicateTrees;
    options {language=Ruby;output=AST;}
    a : ID INT -> {false}? ^(ID INT)
               -> {true}? ^(INT ID)
               -> ID
      ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(2 a)';	0;
0S; 
;"#test :SimpleTree do
  result = parse(<<-'END', :a, '-34')
    grammar SimpleTree;
    options {language=Ruby;output=AST;}
    a : op INT -> ^(op INT);
    op : '+'|'-' ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(- 34)'
end;"SimpleTree;"  result = parse(<<-'END', :a, '-34')
    grammar SimpleTree;
    options {language=Ruby;output=AST;}
    a : op INT -> ^(op INT);
    op : '+'|'-' ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(- 34)';	0;
0S; 
;"&test :SimpleTree2 do
  result = parse(<<-'END', :a, '+ 34')
    grammar SimpleTree2;
    options {language=Ruby;output=AST;}
    a : op INT -> ^(INT op);
    op : '+'|'-' ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(34 +)'
end;"SimpleTree2;"  result = parse(<<-'END', :a, '+ 34')
    grammar SimpleTree2;
    options {language=Ruby;output=AST;}
    a : op INT -> ^(INT op);
    op : '+'|'-' ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(34 +)';	0;
0S; 
;"vtest :NestedTrees do
  result = parse(<<-'END', :a, 'var a:int; b:float;')
    grammar NestedTrees;
    options {language=Ruby;output=AST;}
    a : 'var' (ID ':' type ';')+ -> ^('var' ^(':' ID type)+) ;
    type : 'int' | 'float' ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(var (: a int) (: b float))'
end;"NestedTrees;"]  result = parse(<<-'END', :a, 'var a:int; b:float;')
    grammar NestedTrees;
    options {language=Ruby;output=AST;}
    a : 'var' (ID ':' type ';')+ -> ^('var' ^(':' ID type)+) ;
    type : 'int' | 'float' ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(var (: a int) (: b float))';	0;
0S; 
;"itest :ImaginaryTokenCopy do
  result = parse(<<-'END', :a, 'a,b,c')
    grammar ImaginaryTokenCopy;
    options {language=Ruby;output=AST;}
    tokens {VAR;}
    a : ID (',' ID)*-> ^(VAR ID)+ ;
    type : 'int' | 'float' ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(VAR a) (VAR b) (VAR c)'
end;"ImaginaryTokenCopy;"I  result = parse(<<-'END', :a, 'a,b,c')
    grammar ImaginaryTokenCopy;
    options {language=Ruby;output=AST;}
    tokens {VAR;}
    a : ID (',' ID)*-> ^(VAR ID)+ ;
    type : 'int' | 'float' ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(VAR a) (VAR b) (VAR c)';	0;
0S; 
;"Ltest :TokenUnreferencedOnLeftButDefined do
  result = parse(<<-'END', :a, 'a')
    grammar TokenUnreferencedOnLeftButDefined;
    options {language=Ruby;output=AST;}
    tokens {VAR;}
    a : b -> ID ;
    b : ID ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'ID'
end;"&TokenUnreferencedOnLeftButDefined;"  result = parse(<<-'END', :a, 'a')
    grammar TokenUnreferencedOnLeftButDefined;
    options {language=Ruby;output=AST;}
    tokens {VAR;}
    a : b -> ID ;
    b : ID ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'ID';	0;
0S; 
;"~test :ImaginaryTokenCopySetText do
  result = parse(<<-'END', :a, 'a,b,c')
    grammar ImaginaryTokenCopySetText;
    options {language=Ruby;output=AST;}
    tokens {VAR;}
    a : ID (',' ID)*-> ^(VAR["var"] ID)+ ;
    type : 'int' | 'float' ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(var a) (var b) (var c)'
end;"ImaginaryTokenCopySetText;"W  result = parse(<<-'END', :a, 'a,b,c')
    grammar ImaginaryTokenCopySetText;
    options {language=Ruby;output=AST;}
    tokens {VAR;}
    a : ID (',' ID)*-> ^(VAR["var"] ID)+ ;
    type : 'int' | 'float' ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(var a) (var b) (var c)';	0;
0S; 
;"test :ImaginaryTokenNoCopyFromToken do
  result = parse(<<-'END', :a, '{a b c}')
    grammar ImaginaryTokenNoCopyFromToken;
    options {language=Ruby;output=AST;}
    tokens {BLOCK;}
    a : lc='{' ID+ '}' -> ^(BLOCK[$lc] ID+) ;
    type : 'int' | 'float' ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '({ a b c)'
end;""ImaginaryTokenNoCopyFromToken;"T  result = parse(<<-'END', :a, '{a b c}')
    grammar ImaginaryTokenNoCopyFromToken;
    options {language=Ruby;output=AST;}
    tokens {BLOCK;}
    a : lc='{' ID+ '}' -> ^(BLOCK[$lc] ID+) ;
    type : 'int' | 'float' ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '({ a b c)';	0;
0S; 
;"™test :ImaginaryTokenNoCopyFromTokenSetText do
  result = parse(<<-'END', :a, '{a b c}')
    grammar ImaginaryTokenNoCopyFromTokenSetText;
    options {language=Ruby;output=AST;}
    tokens {BLOCK;}
    a : lc='{' ID+ '}' -> ^(BLOCK[$lc,"block"] ID+) ;
    type : 'int' | 'float' ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(block a b c)'
end;")ImaginaryTokenNoCopyFromTokenSetText;"g  result = parse(<<-'END', :a, '{a b c}')
    grammar ImaginaryTokenNoCopyFromTokenSetText;
    options {language=Ruby;output=AST;}
    tokens {BLOCK;}
    a : lc='{' ID+ '}' -> ^(BLOCK[$lc,"block"] ID+) ;
    type : 'int' | 'float' ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(block a b c)';	0;
0S; 
;"Œtest :MixedRewriteAndAutoAST do
  result = parse(<<-'END', :a, 'a 1 2')
    grammar MixedRewriteAndAutoAST;
    options {language=Ruby;output=AST;}
    tokens {BLOCK;}
    a : b b^ ; // 2nd b matches only an INT; can make it root
    b : ID INT -> INT ID
      | INT
      ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;
  END
  result.should == '(2 1 a)'
end;"MixedRewriteAndAutoAST;"h  result = parse(<<-'END', :a, 'a 1 2')
    grammar MixedRewriteAndAutoAST;
    options {language=Ruby;output=AST;}
    tokens {BLOCK;}
    a : b b^ ; // 2nd b matches only an INT; can make it root
    b : ID INT -> INT ID
      | INT
      ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;
  END
  result.should == '(2 1 a)';	0;
0S; 
;"`test :SubruleWithRewrite do
  result = parse(<<-'END', :a, 'a 1 2 3')
    grammar SubruleWithRewrite;
    options {language=Ruby;output=AST;}
    tokens {BLOCK;}
    a : b b ;
    b : (ID INT -> INT ID | INT INT -> INT+ )
      ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '1 a 2 3'
end;"SubruleWithRewrite;"@  result = parse(<<-'END', :a, 'a 1 2 3')
    grammar SubruleWithRewrite;
    options {language=Ruby;output=AST;}
    tokens {BLOCK;}
    a : b b ;
    b : (ID INT -> INT ID | INT INT -> INT+ )
      ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '1 a 2 3';	0;
0S; 
;"Átest :SubruleWithRewrite2 do
  result = parse(<<-'END', :a, 'int a; int b=3;')
    grammar SubruleWithRewrite2;
    options {language=Ruby;output=AST;}
    tokens {TYPE;}
    a : b b ;
    b : 'int'
        ( ID -> ^(TYPE 'int' ID)
        | ID '=' INT -> ^(TYPE 'int' ID INT)
        )
        ';'
      ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(TYPE int a) (TYPE int b 3)'
end;"SubruleWithRewrite2;"   result = parse(<<-'END', :a, 'int a; int b=3;')
    grammar SubruleWithRewrite2;
    options {language=Ruby;output=AST;}
    tokens {TYPE;}
    a : b b ;
    b : 'int'
        ( ID -> ^(TYPE 'int' ID)
        | ID '=' INT -> ^(TYPE 'int' ID INT)
        )
        ';'
      ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(TYPE int a) (TYPE int b 3)';	0;
0S; 
;"¶test :NestedRewriteShutsOffAutoAST do
  result = parse(<<-'END', :a, 'a b c d; 42')
    grammar NestedRewriteShutsOffAutoAST;
    options {language=Ruby;output=AST;}
    tokens {BLOCK;}
    a : b b ;
    b : ID ( ID (last=ID -> $last)+ ) ';' // get last ID
      | INT // should still get auto AST construction
      ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'd 42'
end;"!NestedRewriteShutsOffAutoAST;"Œ  result = parse(<<-'END', :a, 'a b c d; 42')
    grammar NestedRewriteShutsOffAutoAST;
    options {language=Ruby;output=AST;}
    tokens {BLOCK;}
    a : b b ;
    b : ID ( ID (last=ID -> $last)+ ) ';' // get last ID
      | INT // should still get auto AST construction
      ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'd 42';	0;
0S; 
;"Atest :RewriteActions do
  result = parse(<<-'END', :a, '3')
    grammar RewriteActions;
    options {language=Ruby;output=AST;}
    a : atom -> ^({ @adaptor.create!(INT,"9") } atom) ;
    atom : INT ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(9 3)'
end;"RewriteActions;"%  result = parse(<<-'END', :a, '3')
    grammar RewriteActions;
    options {language=Ruby;output=AST;}
    a : atom -> ^({ @adaptor.create!(INT,"9") } atom) ;
    atom : INT ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(9 3)';	0;
0S; 
;">test :RewriteActions2 do
  result = parse(<<-'END', :a, '3')
    grammar RewriteActions2;
    options {language=Ruby;output=AST;}
    a : atom -> { @adaptor.create!(INT,"9") } atom ;
    atom : INT ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '9 3'
end;"RewriteActions2;"!  result = parse(<<-'END', :a, '3')
    grammar RewriteActions2;
    options {language=Ruby;output=AST;}
    a : atom -> { @adaptor.create!(INT,"9") } atom ;
    atom : INT ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '9 3';	0;
0S; 
;"btest :RefToOldValue do
  result = parse(<<-'END', :a, '3+4+5')
    grammar RefToOldValue;
    options {language=Ruby;output=AST;}
    tokens {BLOCK;}
    a : (atom -> atom) (op='+' r=atom -> ^($op $a $r) )* ;
    atom : INT ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(+ (+ 3 4) 5)'
end;"RefToOldValue;"G  result = parse(<<-'END', :a, '3+4+5')
    grammar RefToOldValue;
    options {language=Ruby;output=AST;}
    tokens {BLOCK;}
    a : (atom -> atom) (op='+' r=atom -> ^($op $a $r) )* ;
    atom : INT ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(+ (+ 3 4) 5)';	0;
0S; 
;"ctest :CopySemanticsForRules do
  result = parse(<<-'END', :a, '3')
    grammar CopySemanticsForRules;
    options {language=Ruby;output=AST;}
    tokens {BLOCK;}
    a : atom -> ^(atom atom) ; // NOT CYCLE! (dup atom)
    atom : INT ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(3 3)'
end;"CopySemanticsForRules;"@  result = parse(<<-'END', :a, '3')
    grammar CopySemanticsForRules;
    options {language=Ruby;output=AST;}
    tokens {BLOCK;}
    a : atom -> ^(atom atom) ; // NOT CYCLE! (dup atom)
    atom : INT ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(3 3)';	0;
0S; 
;"Ptest :CopySemanticsForRules2 do
  result = parse(<<-'END', :a, 'int a,b,c;')
    grammar CopySemanticsForRules2;
    options {language=Ruby;output=AST;}
    a : type ID (',' ID)* ';' -> ^(type ID)+ ;
    type : 'int' ;
    ID : 'a'..'z'+ ;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(int a) (int b) (int c)'
end;"CopySemanticsForRules2;",  result = parse(<<-'END', :a, 'int a,b,c;')
    grammar CopySemanticsForRules2;
    options {language=Ruby;output=AST;}
    a : type ID (',' ID)* ';' -> ^(type ID)+ ;
    type : 'int' ;
    ID : 'a'..'z'+ ;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(int a) (int b) (int c)';	0;
0S; 
;"štest :CopySemanticsForRules3 do
  result = parse(<<-'END', :a, 'public int a,b,c;')
    grammar CopySemanticsForRules3;
    options {language=Ruby;output=AST;}
    a : modifier? type ID (',' ID)* ';' -> ^(type modifier? ID)+ ;
    type : 'int' ;
    modifier : 'public' ;
    ID : 'a'..'z'+ ;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(int public a) (int public b) (int public c)'
end;"CopySemanticsForRules3;"v  result = parse(<<-'END', :a, 'public int a,b,c;')
    grammar CopySemanticsForRules3;
    options {language=Ruby;output=AST;}
    a : modifier? type ID (',' ID)* ';' -> ^(type modifier? ID)+ ;
    type : 'int' ;
    modifier : 'public' ;
    ID : 'a'..'z'+ ;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(int public a) (int public b) (int public c)';	0;
0S; 
;"étest :CopySemanticsForRules3Double do
  result = parse(<<-'END', :a, 'public int a,b,c;')
    grammar CopySemanticsForRules3Double;
    options {language=Ruby;output=AST;}
    a : modifier? type ID (',' ID)* ';' -> ^(type modifier? ID)+ ^(type modifier? ID)+ ;
    type : 'int' ;
    modifier : 'public' ;
    ID : 'a'..'z'+ ;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(int public a) (int public b) (int public c) (int public a) (int public b) (int public c)'
end;"!CopySemanticsForRules3Double;"¿  result = parse(<<-'END', :a, 'public int a,b,c;')
    grammar CopySemanticsForRules3Double;
    options {language=Ruby;output=AST;}
    a : modifier? type ID (',' ID)* ';' -> ^(type modifier? ID)+ ^(type modifier? ID)+ ;
    type : 'int' ;
    modifier : 'public' ;
    ID : 'a'..'z'+ ;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(int public a) (int public b) (int public c) (int public a) (int public b) (int public c)';	0;
0S; 
;"Åtest :CopySemanticsForRules4 do
  result = parse(<<-'END', :a, 'public int a,b,c;')
    grammar CopySemanticsForRules4;
    options {language=Ruby;output=AST;}
    tokens {MOD;}
    a : modifier? type ID (',' ID)* ';' -> ^(type ^(MOD modifier)? ID)+ ;
    type : 'int' ;
    modifier : 'public' ;
    ID : 'a'..'z'+ ;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(int (MOD public) a) (int (MOD public) b) (int (MOD public) c)'
end;"CopySemanticsForRules4;"¡  result = parse(<<-'END', :a, 'public int a,b,c;')
    grammar CopySemanticsForRules4;
    options {language=Ruby;output=AST;}
    tokens {MOD;}
    a : modifier? type ID (',' ID)* ';' -> ^(type ^(MOD modifier)? ID)+ ;
    type : 'int' ;
    modifier : 'public' ;
    ID : 'a'..'z'+ ;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(int (MOD public) a) (int (MOD public) b) (int (MOD public) c)';	0;
0S; 
;".test :CopySemanticsLists do
  result = parse(<<-'END', :a, 'a,b,c;')
    grammar CopySemanticsLists;
    options {language=Ruby;output=AST;}
    tokens {MOD;}
    a : ID (',' ID)* ';' -> ID+ ID+ ;
    ID : 'a'..'z'+ ;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'a b c a b c'
end;"CopySemanticsLists;"  result = parse(<<-'END', :a, 'a,b,c;')
    grammar CopySemanticsLists;
    options {language=Ruby;output=AST;}
    tokens {MOD;}
    a : ID (',' ID)* ';' -> ID+ ID+ ;
    ID : 'a'..'z'+ ;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'a b c a b c';	0;
0S; 
;"test :CopyRuleLabel do
  result = parse(<<-'END', :a, 'a')
    grammar CopyRuleLabel;
    options {language=Ruby;output=AST;}
    tokens {BLOCK;}
    a : x=b -> $x $x;
    b : ID ;
    ID : 'a'..'z'+ ;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'a a'
end;"CopyRuleLabel;"û  result = parse(<<-'END', :a, 'a')
    grammar CopyRuleLabel;
    options {language=Ruby;output=AST;}
    tokens {BLOCK;}
    a : x=b -> $x $x;
    b : ID ;
    ID : 'a'..'z'+ ;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'a a';	0;
0S; 
;"test :CopyRuleLabel2 do
  result = parse(<<-'END', :a, 'a')
    grammar CopyRuleLabel2;
    options {language=Ruby;output=AST;}
    tokens {BLOCK;}
    a : x=b -> ^($x $x);
    b : ID ;
    ID : 'a'..'z'+ ;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(a a)'
end;"CopyRuleLabel2;"  result = parse(<<-'END', :a, 'a')
    grammar CopyRuleLabel2;
    options {language=Ruby;output=AST;}
    tokens {BLOCK;}
    a : x=b -> ^($x $x);
    b : ID ;
    ID : 'a'..'z'+ ;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(a a)';	0;
0S; 
;"Otest :QueueingOfTokens do
  result = parse(<<-'END', :a, 'int a,b,c;')
    grammar QueueingOfTokens;
    options {language=Ruby;output=AST;}
    a : 'int' ID (',' ID)* ';' -> ^('int' ID+) ;
    op : '+'|'-' ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(int a b c)'
end;"QueueingOfTokens;"1  result = parse(<<-'END', :a, 'int a,b,c;')
    grammar QueueingOfTokens;
    options {language=Ruby;output=AST;}
    a : 'int' ID (',' ID)* ';' -> ^('int' ID+) ;
    op : '+'|'-' ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(int a b c)';	0;
0S; 
;">test :CopyOfTokens do
  result = parse(<<-'END', :a, 'int a;')
    grammar CopyOfTokens;
    options {language=Ruby;output=AST;}
    a : 'int' ID ';' -> 'int' ID 'int' ID ;
    op : '+'|'-' ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'int a int a'
end;"CopyOfTokens;"$  result = parse(<<-'END', :a, 'int a;')
    grammar CopyOfTokens;
    options {language=Ruby;output=AST;}
    a : 'int' ID ';' -> 'int' ID 'int' ID ;
    op : '+'|'-' ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'int a int a';	0;
0S; 
;"Ytest :TokenCopyInLoop do
  result = parse(<<-'END', :a, 'int a,b,c;')
    grammar TokenCopyInLoop;
    options {language=Ruby;output=AST;}
    a : 'int' ID (',' ID)* ';' -> ^('int' ID)+ ;
    op : '+'|'-' ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(int a) (int b) (int c)'
end;"TokenCopyInLoop;"<  result = parse(<<-'END', :a, 'int a,b,c;')
    grammar TokenCopyInLoop;
    options {language=Ruby;output=AST;}
    a : 'int' ID (',' ID)* ';' -> ^('int' ID)+ ;
    op : '+'|'-' ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(int a) (int b) (int c)';	0;
0S; 
;"™test :TokenCopyInLoopAgainstTwoOthers do
  result = parse(<<-'END', :a, 'int a:1,b:2,c:3;')
    grammar TokenCopyInLoopAgainstTwoOthers;
    options {language=Ruby;output=AST;}
    a : 'int' ID ':' INT (',' ID ':' INT)* ';' -> ^('int' ID INT)+ ;
    op : '+'|'-' ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(int a 1) (int b 2) (int c 3)'
end;"$TokenCopyInLoopAgainstTwoOthers;"l  result = parse(<<-'END', :a, 'int a:1,b:2,c:3;')
    grammar TokenCopyInLoopAgainstTwoOthers;
    options {language=Ruby;output=AST;}
    a : 'int' ID ':' INT (',' ID ':' INT)* ';' -> ^('int' ID INT)+ ;
    op : '+'|'-' ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(int a 1) (int b 2) (int c 3)';	0;
0S; 
;"Itest :ListRefdOneAtATime do
  result = parse(<<-'END', :a, 'a b c')
    grammar ListRefdOneAtATime;
    options {language=Ruby;output=AST;}
    a : ID+ -> ID ID ID ; // works if 3 input IDs
    op : '+'|'-' ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'a b c'
end;"ListRefdOneAtATime;")  result = parse(<<-'END', :a, 'a b c')
    grammar ListRefdOneAtATime;
    options {language=Ruby;output=AST;}
    a : ID+ -> ID ID ID ; // works if 3 input IDs
    op : '+'|'-' ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'a b c';	0;
0S; 
;"etest :SplitListWithLabels do
  result = parse(<<-'END', :a, 'a b c')
    grammar SplitListWithLabels;
    options {language=Ruby;output=AST;}
    tokens {VAR;}
    a : first=ID others+=ID* -> $first VAR $others+ ;
    op : '+'|'-' ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'a VAR b c'
end;"SplitListWithLabels;"D  result = parse(<<-'END', :a, 'a b c')
    grammar SplitListWithLabels;
    options {language=Ruby;output=AST;}
    tokens {VAR;}
    a : first=ID others+=ID* -> $first VAR $others+ ;
    op : '+'|'-' ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'a VAR b c';	0;
0S; 
;"›test :ComplicatedMelange do
  result = parse(<<-'END', :a, 'a a b b b c c c d')
    grammar ComplicatedMelange;
    options {language=Ruby;output=AST;}
    tokens {BLOCK;}
    a : A A b=B B b=B c+=C C c+=C D {s=$D.text} -> A+ B+ C+ D ;
    type : 'int' | 'float' ;
    A : 'a' ;
    B : 'b' ;
    C : 'c' ;
    D : 'd' ;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'a a b b b c c c d'
end;"ComplicatedMelange;"{  result = parse(<<-'END', :a, 'a a b b b c c c d')
    grammar ComplicatedMelange;
    options {language=Ruby;output=AST;}
    tokens {BLOCK;}
    a : A A b=B B b=B c+=C C c+=C D {s=$D.text} -> A+ B+ C+ D ;
    type : 'int' | 'float' ;
    A : 'a' ;
    B : 'b' ;
    C : 'c' ;
    D : 'd' ;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'a a b b b c c c d';	0;
0S; 
;"	test :RuleLabel do
  result = parse(<<-'END', :a, 'a')
    grammar RuleLabel;
    options {language=Ruby;output=AST;}
    tokens {BLOCK;}
    a : x=b -> $x;
    b : ID ;
    ID : 'a'..'z'+ ;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'a'
end;"RuleLabel;"ò  result = parse(<<-'END', :a, 'a')
    grammar RuleLabel;
    options {language=Ruby;output=AST;}
    tokens {BLOCK;}
    a : x=b -> $x;
    b : ID ;
    ID : 'a'..'z'+ ;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'a';	0;
0S; 
;"test :AmbiguousRule do
  result = parse(<<-'END', :a, 'abc 34')
    grammar AmbiguousRule;
    options {language=Ruby;output=AST;}
    a : ID a -> a | INT ;
    ID : 'a'..'z'+ ;
    INT: '0'..'9'+ ;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '34'
end;"AmbiguousRule;"÷  result = parse(<<-'END', :a, 'abc 34')
    grammar AmbiguousRule;
    options {language=Ruby;output=AST;}
    a : ID a -> a | INT ;
    ID : 'a'..'z'+ ;
    INT: '0'..'9'+ ;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '34';	0;
0S; 
;"test :RuleListLabel do
  result = parse(<<-'END', :a, 'a b')
    grammar RuleListLabel;
    options {language=Ruby;output=AST;}
    tokens {BLOCK;}
    a : x+=b x+=b -> $x+;
    b : ID ;
    ID : 'a'..'z'+ ;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'a b'
end;"RuleListLabel;"  result = parse(<<-'END', :a, 'a b')
    grammar RuleListLabel;
    options {language=Ruby;output=AST;}
    tokens {BLOCK;}
    a : x+=b x+=b -> $x+;
    b : ID ;
    ID : 'a'..'z'+ ;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'a b';	0;
0S; 
;"!test :RuleListLabel2 do
  result = parse(<<-'END', :a, 'a b')
    grammar RuleListLabel2;
    options {language=Ruby;output=AST;}
    tokens {BLOCK;}
    a : x+=b x+=b -> $x $x*;
    b : ID ;
    ID : 'a'..'z'+ ;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'a b'
end;"RuleListLabel2;"  result = parse(<<-'END', :a, 'a b')
    grammar RuleListLabel2;
    options {language=Ruby;output=AST;}
    tokens {BLOCK;}
    a : x+=b x+=b -> $x $x*;
    b : ID ;
    ID : 'a'..'z'+ ;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'a b';	0;
0S; 
;"test :Optional do
  result = parse(<<-'END', :a, 'a')
    grammar Optional;
    options {language=Ruby;output=AST;}
    tokens {BLOCK;}
    a : x=b (y=b)? -> $x $y?;
    b : ID ;
    ID : 'a'..'z'+ ;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'a'
end;"Optional;"ü  result = parse(<<-'END', :a, 'a')
    grammar Optional;
    options {language=Ruby;output=AST;}
    tokens {BLOCK;}
    a : x=b (y=b)? -> $x $y?;
    b : ID ;
    ID : 'a'..'z'+ ;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'a';	0;
0S; 
;"test :Optional2 do
  result = parse(<<-'END', :a, 'a b')
    grammar Optional2;
    options {language=Ruby;output=AST;}
    tokens {BLOCK;}
    a : x=ID (y=b)? -> $x $y?;
    b : ID ;
    ID : 'a'..'z'+ ;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'a b'
end;"Optional2;"  result = parse(<<-'END', :a, 'a b')
    grammar Optional2;
    options {language=Ruby;output=AST;}
    tokens {BLOCK;}
    a : x=ID (y=b)? -> $x $y?;
    b : ID ;
    ID : 'a'..'z'+ ;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'a b';	0;
0S; 
;"test :Optional3 do
  result = parse(<<-'END', :a, 'a b')
    grammar Optional3;
    options {language=Ruby;output=AST;}
    tokens {BLOCK;}
    a : x=ID (y=b)? -> ($x $y)?;
    b : ID ;
    ID : 'a'..'z'+ ;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'a b'
end;"Optional3;"  result = parse(<<-'END', :a, 'a b')
    grammar Optional3;
    options {language=Ruby;output=AST;}
    tokens {BLOCK;}
    a : x=ID (y=b)? -> ($x $y)?;
    b : ID ;
    ID : 'a'..'z'+ ;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'a b';	0;
0S; 
;"test :Optional4 do
  result = parse(<<-'END', :a, 'a b')
    grammar Optional4;
    options {language=Ruby;output=AST;}
    tokens {BLOCK;}
    a : x+=ID (y=b)? -> ($x $y)?;
    b : ID ;
    ID : 'a'..'z'+ ;
    WS : (' '|'\n') {$channel=HIDDEN;} ;
  END
  result.should == 'a b'
end;"Optional4;"  result = parse(<<-'END', :a, 'a b')
    grammar Optional4;
    options {language=Ruby;output=AST;}
    tokens {BLOCK;}
    a : x+=ID (y=b)? -> ($x $y)?;
    b : ID ;
    ID : 'a'..'z'+ ;
    WS : (' '|'\n') {$channel=HIDDEN;} ;
  END
  result.should == 'a b';	0;
0S; 
;"(test :Optional5 do
  result = parse(<<-'END', :a, 'a')
    grammar Optional5;
    options {language=Ruby;output=AST;}
    tokens {BLOCK;}
    a : ID -> ID? ; // match an ID to optional ID
    b : ID ;
    ID : 'a'..'z'+ ;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'a'
end;"Optional5;"  result = parse(<<-'END', :a, 'a')
    grammar Optional5;
    options {language=Ruby;output=AST;}
    tokens {BLOCK;}
    a : ID -> ID? ; // match an ID to optional ID
    b : ID ;
    ID : 'a'..'z'+ ;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == 'a';	0;
0S; 
;";test :ArbitraryExprType do
  result = parse(<<-'END', :a, 'a b')
    grammar ArbitraryExprType;
    options {language=Ruby;output=AST;}
    tokens {BLOCK;}
    a : x+=b x+=b -> {ANTLR3::CommonTree.new(nil)};
    b : ID ;
    ID : 'a'..'z'+ ;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == ''
end;"ArbitraryExprType;"  result = parse(<<-'END', :a, 'a b')
    grammar ArbitraryExprType;
    options {language=Ruby;output=AST;}
    tokens {BLOCK;}
    a : x+=b x+=b -> {ANTLR3::CommonTree.new(nil)};
    b : ID ;
    ID : 'a'..'z'+ ;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '';	0;
0S; 
;"test :Set do
  result = parse(<<-'END', :a, '2 a 34 de')
    grammar SetT;
    options {language=Ruby;output=AST;} 
    a: (INT|ID)+ -> INT+ ID+ ;
    INT: '0'..'9'+;
    ID : 'a'..'z'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '2 34 a de'
end;"Set;"ü  result = parse(<<-'END', :a, '2 a 34 de')
    grammar SetT;
    options {language=Ruby;output=AST;} 
    a: (INT|ID)+ -> INT+ ID+ ;
    INT: '0'..'9'+;
    ID : 'a'..'z'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '2 34 a de';	0;
0S; 
;"ýtest :Set2 do
  result = parse(<<-'END', :a, '2')
    grammar Set2;
    options {language=Ruby;output=AST;} 
    a: (INT|ID) -> INT? ID? ;
    INT: '0'..'9'+;
    ID : 'a'..'z'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '2'
end;"	Set2;"ë  result = parse(<<-'END', :a, '2')
    grammar Set2;
    options {language=Ruby;output=AST;} 
    a: (INT|ID) -> INT? ID? ;
    INT: '0'..'9'+;
    ID : 'a'..'z'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '2';	0;
0S; 
;"Dtest :SetWithLabel do
  warn('test SetWithLabel officially broken')
  #result = parse(<<-'END', :a, '2')
  #  grammar SetWithLabel;
  #  options {language=Ruby;output=AST;} 
  #  a : x=(INT|ID) -> $x ;
  #  INT: '0'..'9'+;
  #  ID : 'a'..'z'+;
  #  WS : (' '|'\n') {$channel=HIDDEN;} ;
  #
  #END
  #result.should == '2'
end;"SetWithLabel;"*  warn('test SetWithLabel officially broken')
  #result = parse(<<-'END', :a, '2')
  #  grammar SetWithLabel;
  #  options {language=Ruby;output=AST;} 
  #  a : x=(INT|ID) -> $x ;
  #  INT: '0'..'9'+;
  #  ID : 'a'..'z'+;
  #  WS : (' '|'\n') {$channel=HIDDEN;} ;
  #
  #END
  #result.should == '2';	0;
0S; 
;"ktest :RewriteAction do
  result = parse(<<-'END', :r, '25')
    grammar RewriteAction; 
    options {language=Ruby;output=AST;}
    tokens { FLOAT; }
    r
        : INT -> {ANTLR3::CommonTree.new(create_token(FLOAT, nil, "#{$INT.text}.0"))} 
        ; 
    INT : '0'..'9'+; 
    WS: (' ' | '\n' | '\t')+ {$channel = HIDDEN;};

  END
  result.should == '25.0'
end;"RewriteAction;"P  result = parse(<<-'END', :r, '25')
    grammar RewriteAction; 
    options {language=Ruby;output=AST;}
    tokens { FLOAT; }
    r
        : INT -> {ANTLR3::CommonTree.new(create_token(FLOAT, nil, "#{$INT.text}.0"))} 
        ; 
    INT : '0'..'9'+; 
    WS: (' ' | '\n' | '\t')+ {$channel = HIDDEN;};

  END
  result.should == '25.0';	0;
0S; 
;"Ïtest :OptionalSubruleWithoutRealElements do
  result = parse(<<-'END', :modulo, 'modulo abc (x y #)')
    grammar OptionalSubruleWithoutRealElements;
    options {language=Ruby;output=AST;} 
    tokens {PARMS;} 
    
    modulo 
     : 'modulo' ID ('(' parms+ ')')? -> ^('modulo' ID ^(PARMS parms+)?) 
     ; 
    parms : '#'|ID; 
    ID : ('a'..'z' | 'A'..'Z')+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(modulo abc (PARMS x y #))'
end;"'OptionalSubruleWithoutRealElements;"Ÿ  result = parse(<<-'END', :modulo, 'modulo abc (x y #)')
    grammar OptionalSubruleWithoutRealElements;
    options {language=Ruby;output=AST;} 
    tokens {PARMS;} 
    
    modulo 
     : 'modulo' ID ('(' parms+ ')')? -> ^('modulo' ID ^(PARMS parms+)?) 
     ; 
    parms : '#'|ID; 
    ID : ('a'..'z' | 'A'..'Z')+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '(modulo abc (PARMS x y #))';	0;
0S; 
;"test :Wildcard do
  result = parse(<<-'END', :a, 'abc 34')
    grammar Wildcard;
    options {language=Ruby;output=AST;}
    a : ID c=. -> $c;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '34'
end;"Wildcard;"î  result = parse(<<-'END', :a, 'abc 34')
    grammar Wildcard;
    options {language=Ruby;output=AST;}
    a : ID c=. -> $c;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  result.should == '34';	0;
0S; 
;"×test :ExtraTokenInSimpleDecl do
  result, errors = parse(<<-'END', :decl, 'int 34 x=1;', true)
    grammar ExtraTokenInSimpleDecl;
    options {language=Ruby;output=AST;}
    tokens {EXPR;}
    decl : type ID '=' INT ';' -> ^(EXPR type ID INT) ;
    type : 'int' | 'float' ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  errors.should == ['line 1:4 extraneous input "34" expecting ID']
  result.should == '(EXPR int x 1)'
end;"ExtraTokenInSimpleDecl;"³  result, errors = parse(<<-'END', :decl, 'int 34 x=1;', true)
    grammar ExtraTokenInSimpleDecl;
    options {language=Ruby;output=AST;}
    tokens {EXPR;}
    decl : type ID '=' INT ';' -> ^(EXPR type ID INT) ;
    type : 'int' | 'float' ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  errors.should == ['line 1:4 extraneous input "34" expecting ID']
  result.should == '(EXPR int x 1)';	0;
0S; 
;"Ëtest :MissingIDInSimpleDecl do
  result, errors = parse(<<-'END', :decl, 'int =1;', true)
    grammar MissingIDInSimpleDecl;
    options {language=Ruby;output=AST;}
    tokens {EXPR;}
    decl : type ID '=' INT ';' -> ^(EXPR type ID INT) ;
    type : 'int' | 'float' ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  errors.should == ['line 1:4 missing ID at "="']
  result.should == '(EXPR int <missing ID> 1)'
end;"MissingIDInSimpleDecl;"¨  result, errors = parse(<<-'END', :decl, 'int =1;', true)
    grammar MissingIDInSimpleDecl;
    options {language=Ruby;output=AST;}
    tokens {EXPR;}
    decl : type ID '=' INT ';' -> ^(EXPR type ID INT) ;
    type : 'int' | 'float' ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  errors.should == ['line 1:4 missing ID at "="']
  result.should == '(EXPR int <missing ID> 1)';	0;
0S; 
;"Ûtest :MissingSetInSimpleDecl do
  result, errors = parse(<<-'END', :decl, 'x=1;', true)
    grammar MissingSetInSimpleDecl;
    options {language=Ruby;output=AST;}
    tokens {EXPR;}
    decl : type ID '=' INT ';' -> ^(EXPR type ID INT) ;
    type : 'int' | 'float' ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  errors.should == ['line 1:0 mismatched input "x" expecting set nil']
  result.should == '(EXPR <error: x> x 1)'
end;"MissingSetInSimpleDecl;"·  result, errors = parse(<<-'END', :decl, 'x=1;', true)
    grammar MissingSetInSimpleDecl;
    options {language=Ruby;output=AST;}
    tokens {EXPR;}
    decl : type ID '=' INT ';' -> ^(EXPR type ID INT) ;
    type : 'int' | 'float' ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  errors.should == ['line 1:0 mismatched input "x" expecting set nil']
  result.should == '(EXPR <error: x> x 1)';	0;
0S; 
;"*test :MissingTokenGivesErrorNode do
  require 'trace-event'
  #Tracer.new do |event|
  #  puts(event.to_s + ' : %p' % event.__self__) if event.__self__.class.to_s =~ /CommonToken\b/
  #end.trace do
  result, errors = parse(<<-'END', :a, 'abc', true)
    grammar MissingTokenGivesErrorNode;
    options {language=Ruby;output=AST;}
    a : ID INT -> ID INT ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  errors.should == ["line 0:-1 missing INT at \"<EOF>\""]
  result.should == 'abc <missing INT>'
  #end
end;"MissingTokenGivesErrorNode;"  require 'trace-event'
  #Tracer.new do |event|
  #  puts(event.to_s + ' : %p' % event.__self__) if event.__self__.class.to_s =~ /CommonToken\b/
  #end.trace do
  result, errors = parse(<<-'END', :a, 'abc', true)
    grammar MissingTokenGivesErrorNode;
    options {language=Ruby;output=AST;}
    a : ID INT -> ID INT ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  errors.should == ["line 0:-1 missing INT at \"<EOF>\""]
  result.should == 'abc <missing INT>'
  #end;	0;
0S; 
;"¥test :ExtraTokenGivesErrorNode do
  result, errors = parse(<<-'END', :a, 'abc ick 34', true)
    grammar ExtraTokenGivesErrorNode;
    options {language=Ruby;output=AST;}
    a : b c -> b c;
    b : ID -> ID ;
    c : INT -> INT ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  errors.should == ['line 1:4 extraneous input "ick" expecting INT']
  result.should == 'abc 34'
end;"ExtraTokenGivesErrorNode;"  result, errors = parse(<<-'END', :a, 'abc ick 34', true)
    grammar ExtraTokenGivesErrorNode;
    options {language=Ruby;output=AST;}
    a : b c -> b c;
    b : ID -> ID ;
    c : INT -> INT ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  errors.should == ['line 1:4 extraneous input "ick" expecting INT']
  result.should == 'abc 34';	0;
0S; 
;"test :MissingFirstTokenGivesErrorNode do
  result, errors = parse(<<-'END', :a, '34', true)
    grammar MissingFirstTokenGivesErrorNode;
    options {language=Ruby;output=AST;}
    a : ID INT -> ID INT ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  errors.should == ['line 1:0 missing ID at "34"']
  result.should == '<missing ID> 34'
end;"$MissingFirstTokenGivesErrorNode;"T  result, errors = parse(<<-'END', :a, '34', true)
    grammar MissingFirstTokenGivesErrorNode;
    options {language=Ruby;output=AST;}
    a : ID INT -> ID INT ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  errors.should == ['line 1:0 missing ID at "34"']
  result.should == '<missing ID> 34';	0;
0S; 
;"¤test :MissingFirstTokenGivesErrorNode2 do
  result, errors = parse(<<-'END', :a, '34', true)
    grammar MissingFirstTokenGivesErrorNode2;
    options {language=Ruby;output=AST;}
    a : b c -> b c;
    b : ID -> ID ;
    c : INT -> INT ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  errors.should == ['line 1:0 missing ID at "34"']
  result.should == '<missing ID> 34'
end;"%MissingFirstTokenGivesErrorNode2;"v  result, errors = parse(<<-'END', :a, '34', true)
    grammar MissingFirstTokenGivesErrorNode2;
    options {language=Ruby;output=AST;}
    a : b c -> b c;
    b : ID -> ID ;
    c : INT -> INT ;
    ID : 'a'..'z'+ ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  errors.should == ['line 1:0 missing ID at "34"']
  result.should == '<missing ID> 34';	0;
0S; 
;"átest :NoViableAltGivesErrorNode do
  result, errors = parse(<<-'END', :a, '*', true)
    grammar NoViableAltGivesErrorNode;
    options {language=Ruby;output=AST;}
    a : b -> b | c -> c;
    b : ID -> ID ;
    c : INT -> INT ;
    ID : 'a'..'z'+ ;
    S : '*' ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  errors.should == ['line 1:0 no viable alternative at input "*"']
  result.should == '<unexpected: 0 S["*"] @ line 1 col 0 (0..0), resync = *>'
end;"NoViableAltGivesErrorNode;"º  result, errors = parse(<<-'END', :a, '*', true)
    grammar NoViableAltGivesErrorNode;
    options {language=Ruby;output=AST;}
    a : b -> b | c -> c;
    b : ID -> ID ;
    c : INT -> INT ;
    ID : 'a'..'z'+ ;
    S : '*' ;
    INT : '0'..'9'+;
    WS : (' '|'\n') {$channel=HIDDEN;} ;

  END
  errors.should == ['line 1:0 no viable alternative at input "*"']
  result.should == '<unexpected: 0 S["*"] @ line 1 col 0 (0..0), resync = *>';	0;
0S; 
;"qtest :Cardinality do
  lambda do
    parse(<<-'END', :a, "a b 3 4 5")
      grammar Cardinality;
      options {language=Ruby;output=AST;}
      tokens {BLOCK;}
      a : ID ID INT INT INT -> (ID INT)+;
      ID : 'a'..'z'+ ;
      INT : '0'..'9'+; 
      WS : (' '|'\n') {$channel=HIDDEN;} ;
    END
  end.should raise_error(ANTLR3::Error::RewriteCardinalityError)
end;"Cardinality;"X  lambda do
    parse(<<-'END', :a, "a b 3 4 5")
      grammar Cardinality;
      options {language=Ruby;output=AST;}
      tokens {BLOCK;}
      a : ID ID INT INT INT -> (ID INT)+;
      ID : 'a'..'z'+ ;
      INT : '0'..'9'+; 
      WS : (' '|'\n') {$channel=HIDDEN;} ;
    END
  end.should raise_error(ANTLR3::Error::RewriteCardinalityError);	0;
0S; 
;"‡test :Cardinality2 do
  lambda do
    parse(<<-'END', :a, "a b")
      grammar Cardinality2;
      options {language=Ruby;output=AST;}
      tokens {BLOCK;}
      a : ID+ -> ID ID ID ; // only 2 input IDs
      op : '+'|'-' ;
      ID : 'a'..'z'+ ;
      INT : '0'..'9'+;
      WS : (' '|'\n') {$channel=HIDDEN;} ;
    END
  end.should raise_error(ANTLR3::Error::RewriteCardinalityError)
end;"Cardinality2;"m  lambda do
    parse(<<-'END', :a, "a b")
      grammar Cardinality2;
      options {language=Ruby;output=AST;}
      tokens {BLOCK;}
      a : ID+ -> ID ID ID ; // only 2 input IDs
      op : '+'|'-' ;
      ID : 'a'..'z'+ ;
      INT : '0'..'9'+;
      WS : (' '|'\n') {$channel=HIDDEN;} ;
    END
  end.should raise_error(ANTLR3::Error::RewriteCardinalityError);	0;
0S; 
;"ntest :Cardinality3 do
  lambda do
    parse(<<-'END', :a, "3")
      grammar Cardinality3;
      options {language=Ruby;output=AST;}
      tokens {BLOCK;}
      a : ID? INT -> ID INT ;
      op : '+'|'-' ;
      ID : 'a'..'z'+ ;
      INT : '0'..'9'+;
      WS : (' '|'\n') {$channel=HIDDEN;} ;
    END
  end.should raise_error(ANTLR3::Error::RewriteEmptyStream)
end;"Cardinality3;"T  lambda do
    parse(<<-'END', :a, "3")
      grammar Cardinality3;
      options {language=Ruby;output=AST;}
      tokens {BLOCK;}
      a : ID? INT -> ID INT ;
      op : '+'|'-' ;
      ID : 'a'..'z'+ ;
      INT : '0'..'9'+;
      WS : (' '|'\n') {$channel=HIDDEN;} ;
    END
  end.should raise_error(ANTLR3::Error::RewriteEmptyStream);	0;
0S; 
;"]test :LoopCardinality do
  lambda do
    parse(<<-'END', :a, "3")
      grammar LoopCardinality;
      options {language=Ruby;output=AST;}
      a : ID? INT -> ID+ INT ;
      op : '+'|'-' ;
      ID : 'a'..'z'+ ;
      INT : '0'..'9'+;
      WS : (' '|'\n') {$channel=HIDDEN;} ;
    END
  end.should raise_error(ANTLR3::Error::RewriteEarlyExit)
end;"LoopCardinality;"@  lambda do
    parse(<<-'END', :a, "3")
      grammar LoopCardinality;
      options {language=Ruby;output=AST;}
      a : ID? INT -> ID+ INT ;
      op : '+'|'-' ;
      ID : 'a'..'z'+ ;
      INT : '0'..'9'+;
      WS : (' '|'\n') {$channel=HIDDEN;} ;
    END
  end.should raise_error(ANTLR3::Error::RewriteEarlyExit);	0;
0